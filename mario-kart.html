<!DOCTYPE html>
<html>
<head>
    <title>Mario Kart Lite - 1 Player</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 2px solid #444; background: #228B22; }
        #menu { position: absolute; color: white; font-family: Arial; text-align: center; top: 50%; transform: translateY(-50%); }
        #menu h1 { font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px #ff0; }
        #menu button { background: #e74c3c; color: white; border: none; padding: 15px 30px; font-size: 24px; cursor: pointer; border-radius: 5px; }
        #menu button:hover { background: #c0392b; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div id="menu">
        <h1>MARIO KART LITE</h1>
        <button id="startBtn">START GAME</button>
    </div>

    <script>
        // Game Setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const startBtn = document.getElementById('startBtn');

        // Game State
        let gameState = 'menu'; // 'menu', 'playing', 'gameOver'
        let player = { 
            x: 400, y: 350, width: 30, height: 20, 
            speed: 0, maxSpeed: 8, acceleration: 0.3, friction: 0.08,
            angle: 0, lap: 0, position: 0
        };
        
        // AI Opponents
        let opponents = [
            { x: 350, y: 370, width: 30, height: 20, speed: 3, angle: 0, color: '#3498db', lap: 0, position: 0 },
            { x: 450, y: 330, width: 30, height: 20, speed: 2.5, angle: 0, color: '#f39c12', lap: 0, position: 0 },
            { x: 320, y: 400, width: 30, height: 20, speed: 2.8, angle: 0, color: '#9b59b6', lap: 0, position: 0 }
        ];
        
        // Track system
        let track = {
            centerX: 400, centerY: 250,
            innerRadius: 120, outerRadius: 180,
            checkpoints: [
                { x: 400, y: 70, angle: 0 },
                { x: 580, y: 250, angle: Math.PI/2 },
                { x: 400, y: 430, angle: Math.PI },
                { x: 220, y: 250, angle: 3*Math.PI/2 }
            ]
        };
        
        // Item boxes and power-ups
        let itemBoxes = [
            { x: 300, y: 150, active: true, respawnTimer: 0 },
            { x: 500, y: 150, active: true, respawnTimer: 0 },
            { x: 550, y: 300, active: true, respawnTimer: 0 },
            { x: 250, y: 300, active: true, respawnTimer: 0 },
            { x: 350, y: 380, active: true, respawnTimer: 0 },
            { x: 450, y: 380, active: true, respawnTimer: 0 }
        ];
        
        let powerUpActive = null;
        let powerUpTimer = 0;
        let currentLap = 1;
        let totalLaps = 3;

        // Start Game
        startBtn.addEventListener('click', () => {
            gameState = 'playing';
            menu.style.display = 'none';
            player = { 
                x: 400, y: 350, width: 30, height: 20, 
                speed: 0, maxSpeed: 8, acceleration: 0.3, friction: 0.08,
                angle: 0, lap: 0, position: 0
            };
            // Reset opponents
            opponents.forEach((opp, i) => {
                opp.x = 350 + i * 50;
                opp.y = 350 + i * 30;
                opp.lap = 0;
                opp.position = 0;
            });
            // Reset item boxes
            itemBoxes.forEach(box => {
                box.active = true;
                box.respawnTimer = 0;
            });
            powerUpActive = null;
            powerUpTimer = 0;
            currentLap = 1;
        });

        // Input Handling
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.key] = true);
        window.addEventListener('keyup', (e) => keys[e.key] = false);

        // Game Loop
        function gameLoop() {
            if (gameState === 'playing') {
                // Clear Canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Track
                drawTrack();
                
                // Draw Item Boxes
                drawItemBoxes();
                
                // Update and Draw Opponents
                updateOpponents();
                drawOpponents();
                
                // Draw Player
                drawKart(player, '#e74c3c');
                
                // Handle Input and Player Movement
                handlePlayerMovement();
                
                // Update Item Box Respawn
                updateItemBoxes();
                
                // Handle Power-Up Usage
                handlePowerUps();
                
                // Check Lap Progress
                checkLapProgress();
                
                // Draw UI
                drawUI();
            }

            requestAnimationFrame(gameLoop);
        }
        
        function handlePlayerMovement() {
            // Steering
            if (keys['ArrowLeft'] || keys['a']) {
                player.angle -= 0.05;
            }
            if (keys['ArrowRight'] || keys['d']) {
                player.angle += 0.05;
            }
            
            // Acceleration and braking
            if (keys['ArrowUp'] || keys['w']) {
                player.speed = Math.min(player.speed + player.acceleration, player.maxSpeed);
            } else if (keys['ArrowDown'] || keys['s']) {
                player.speed = Math.max(player.speed - player.acceleration * 2, -player.maxSpeed * 0.5);
            } else {
                player.speed *= (1 - player.friction);
            }
            
            // Update position based on angle and speed
            player.x += Math.cos(player.angle) * player.speed;
            player.y += Math.sin(player.angle) * player.speed;
            
            // Track boundaries
            enforceTrackBoundaries(player);
            
            // Item box collection
            checkItemBoxCollection(player);
        }
        
        function updateOpponents() {
            opponents.forEach(opponent => {
                // Simple AI: follow track
                const centerX = track.centerX;
                const centerY = track.centerY;
                const targetRadius = (track.innerRadius + track.outerRadius) / 2;
                
                const dx = opponent.x - centerX;
                const dy = opponent.y - centerY;
                const currentRadius = Math.sqrt(dx * dx + dy * dy);
                
                // Adjust angle to follow circular track
                opponent.angle += 0.02;
                
                // Move forward
                opponent.x += Math.cos(opponent.angle) * opponent.speed;
                opponent.y += Math.sin(opponent.angle) * opponent.speed;
                
                // Keep on track
                enforceTrackBoundaries(opponent);
            });
        }
        
        function enforceTrackBoundaries(kart) {
            const dx = kart.x - track.centerX;
            const dy = kart.y - track.centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < track.innerRadius) {
                // Push outward
                const angle = Math.atan2(dy, dx);
                kart.x = track.centerX + Math.cos(angle) * track.innerRadius;
                kart.y = track.centerY + Math.sin(angle) * track.innerRadius;
                kart.speed *= 0.5; // Slow down when hitting wall
            } else if (distance > track.outerRadius) {
                // Push inward
                const angle = Math.atan2(dy, dx);
                kart.x = track.centerX + Math.cos(angle) * track.outerRadius;
                kart.y = track.centerY + Math.sin(angle) * track.outerRadius;
                kart.speed *= 0.5; // Slow down when hitting wall
            }
        }
        
        function checkItemBoxCollection(kart) {
            itemBoxes.forEach((box, i) => {
                if (!box.active) return;
                const dx = kart.x - box.x;
                const dy = kart.y - box.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 25) {
                    box.active = false;
                    box.respawnTimer = 300; // 5 seconds at 60fps
                    if (kart === player) {
                        const powerUps = ['mushroom', 'shell', 'banana', 'star'];
                        powerUpActive = powerUps[Math.floor(Math.random() * powerUps.length)];
                        powerUpTimer = 300;
                    }
                }
            });
        }
        
        function updateItemBoxes() {
            itemBoxes.forEach(box => {
                if (!box.active && box.respawnTimer > 0) {
                    box.respawnTimer--;
                    if (box.respawnTimer === 0) {
                        box.active = true;
                    }
                }
            });
        }
        
        function handlePowerUps() {
            if (powerUpTimer > 0) {
                powerUpTimer--;
                if (powerUpTimer === 0) {
                    powerUpActive = null;
                }
            }
            
            // Use power-up
            if (powerUpActive && (keys[' '] || keys['Space'])) {
                switch (powerUpActive) {
                    case 'mushroom':
                        player.speed = Math.min(player.speed + 3, player.maxSpeed + 2);
                        break;
                    case 'star':
                        player.maxSpeed = 12;
                        break;
                    case 'shell':
                        // Simple shell effect - boost forward
                        player.speed = Math.min(player.speed + 2, player.maxSpeed + 1);
                        break;
                    case 'banana':
                        // Create temporary obstacle (simplified)
                        break;
                }
                powerUpActive = null;
                powerUpTimer = 0;
            }
            
            // Reset max speed for star power-up
            if (powerUpActive !== 'star') {
                player.maxSpeed = 8;
            }
        }
        
        function checkLapProgress() {
            // Simple lap detection based on position relative to track center
            const angle = Math.atan2(player.y - track.centerY, player.x - track.centerX);
            const normalizedAngle = ((angle + Math.PI * 2) % (Math.PI * 2));
            
            // Check if player completed a lap (simplified)
            if (normalizedAngle < 0.5 && player.position > Math.PI * 1.5) {
                currentLap++;
                if (currentLap > totalLaps) {
                    gameState = 'gameOver';
                    menu.style.display = 'block';
                    menu.innerHTML = '<h1>RACE COMPLETE!</h1><button onclick="location.reload()">PLAY AGAIN</button>';
                }
            }
            player.position = normalizedAngle;
        }

        // Drawing functions
        function drawTrack() {
            // Background
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Outer track border
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(track.centerX, track.centerY, track.outerRadius + 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Track surface
            ctx.fillStyle = '#444';
            ctx.beginPath();
            ctx.arc(track.centerX, track.centerY, track.outerRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner track border
            ctx.fillStyle = '#8B4513';
            ctx.beginPath();
            ctx.arc(track.centerX, track.centerY, track.innerRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner grass
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.arc(track.centerX, track.centerY, track.innerRadius - 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Track lines
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.setLineDash([20, 20]);
            ctx.beginPath();
            ctx.arc(track.centerX, track.centerY, (track.innerRadius + track.outerRadius) / 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Start/finish line
            ctx.fillStyle = 'white';
            ctx.fillRect(track.centerX - 5, track.centerY - track.outerRadius - 10, 10, track.outerRadius - track.innerRadius + 20);
        }
        
        function drawItemBoxes() {
            itemBoxes.forEach(box => {
                if (box.active) {
                    // Item box
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(box.x - 10, box.y - 10, 20, 20);
                    
                    // Question mark
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('?', box.x, box.y + 5);
                } else if (box.respawnTimer > 0) {
                    // Respawning indicator
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.fillRect(box.x - 10, box.y - 10, 20, 20);
                }
            });
            ctx.textAlign = 'left';
        }
        
        function drawKart(kart, color) {
            ctx.save();
            ctx.translate(kart.x, kart.y);
            ctx.rotate(kart.angle);
            
            // Kart body
            ctx.fillStyle = color;
            ctx.fillRect(-kart.width/2, -kart.height/2, kart.width, kart.height);
            
            // Kart details
            ctx.fillStyle = 'black';
            ctx.fillRect(-kart.width/2 + 5, -kart.height/2 + 2, 4, 4); // Driver
            ctx.fillRect(-kart.width/2 + 5, kart.height/2 - 6, 4, 4);
            
            // Speed boost effect
            if (kart === player && powerUpActive === 'star') {
                ctx.strokeStyle = 'yellow';
                ctx.lineWidth = 3;
                ctx.strokeRect(-kart.width/2 - 3, -kart.height/2 - 3, kart.width + 6, kart.height + 6);
            }
            
            ctx.restore();
        }
        
        function drawOpponents() {
            opponents.forEach(opponent => {
                drawKart(opponent, opponent.color);
            });
        }
        
        function drawUI() {
            // Lap counter
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`Lap ${currentLap}/${totalLaps}`, canvas.width - 20, 30);
            
            // Power-up display
            ctx.textAlign = 'left';
            ctx.font = '20px Arial';
            ctx.fillText(`Power-Up: ${powerUpActive || 'None'}`, 20, 30);
            
            // Speed indicator
            ctx.fillText(`Speed: ${Math.round(player.speed * 10)}`, 20, 55);
            
            // Power-up instructions
            if (powerUpActive) {
                ctx.fillStyle = 'yellow';
                ctx.font = '16px Arial';
                ctx.fillText('Press SPACE to use power-up!', 20, canvas.height - 20);
            }
            
            // Controls
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '14px Arial';
            ctx.fillText('WASD or Arrow Keys to drive', canvas.width - 200, canvas.height - 40);
            ctx.fillText('SPACE to use power-up', canvas.width - 200, canvas.height - 20);
        }

        // Start Game Loop
        gameLoop();
    </script>
</body>
</html>
